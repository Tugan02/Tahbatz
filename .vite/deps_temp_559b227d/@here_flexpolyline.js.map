{
  "version": 3,
  "sources": ["../../node_modules/@here/flexpolyline/index.js"],
  "sourcesContent": ["/*\n * Copyright (C) 2019 HERE Europe B.V.\n * Licensed under MIT, see full license in LICENSE\n * SPDX-License-Identifier: MIT\n * License-Filename: LICENSE\n */\nconst DEFAULT_PRECISION = 5;\n\nconst ENCODING_TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\nconst DECODING_TABLE = [\n    62, -1, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1,\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n    22, 23, 24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\n    36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n];\n\nconst FORMAT_VERSION = 1;\n\nconst ABSENT = 0;\nconst LEVEL = 1;\nconst ALTITUDE = 2;\nconst ELEVATION = 3;\n// Reserved values 4 and 5 should not be selectable\nconst CUSTOM1 = 6;\nconst CUSTOM2 = 7;\n\nconst Num = typeof BigInt !== \"undefined\" ? BigInt : Number;\n\nfunction decode(encoded) {\n    const decoder = decodeUnsignedValues(encoded);\n    const header = decodeHeader(decoder[0], decoder[1]);\n\n    const factorDegree = 10 ** header.precision;\n    const factorZ = 10 ** header.thirdDimPrecision;\n    const { thirdDim } = header;\n\n    let lastLat = 0;\n    let lastLng = 0;\n    let lastZ = 0;\n    const res = [];\n\n    let i = 2;\n    for (;i < decoder.length;) {\n        const deltaLat = toSigned(decoder[i]) / factorDegree;\n        const deltaLng = toSigned(decoder[i + 1]) / factorDegree;\n        lastLat += deltaLat;\n        lastLng += deltaLng;\n\n        if (thirdDim) {\n            const deltaZ = toSigned(decoder[i + 2]) / factorZ;\n            lastZ += deltaZ;\n            res.push([lastLat, lastLng, lastZ]);\n            i += 3;\n        } else {\n            res.push([lastLat, lastLng]);\n            i += 2;\n        }\n    }\n\n    if (i !== decoder.length) {\n        throw new Error('Invalid encoding. Premature ending reached');\n    }\n\n    return {\n        ...header,\n        polyline: res,\n    };\n}\n\nfunction decodeChar(char) {\n    const charCode = char.charCodeAt(0);\n    return DECODING_TABLE[charCode - 45];\n}\n\nfunction decodeUnsignedValues(encoded) {\n    let result = Num(0);\n    let shift = Num(0);\n    const resList = [];\n\n    encoded.split('').forEach((char) => {\n        const value = Num(decodeChar(char));\n        result |= (value & Num(0x1F)) << shift;\n        if ((value & Num(0x20)) === Num(0)) {\n            resList.push(result);\n            result = Num(0);\n            shift = Num(0);\n        } else {\n            shift += Num(5);\n        }\n    });\n\n    if (shift > 0) {\n        throw new Error('Invalid encoding');\n    }\n\n    return resList;\n}\n\nfunction decodeHeader(version, encodedHeader) {\n    if (+version.toString() !== FORMAT_VERSION) {\n        throw new Error('Invalid format version');\n    }\n    const headerNumber = +encodedHeader.toString();\n    const precision = headerNumber & 15;\n    const thirdDim = (headerNumber >> 4) & 7;\n    const thirdDimPrecision = (headerNumber >> 7) & 15;\n    return { precision, thirdDim, thirdDimPrecision };\n}\n\nfunction toSigned(val) {\n    // Decode the sign from an unsigned value\n    let res = val;\n    if (res & Num(1)) {\n        res = ~res;\n    }\n    res >>= Num(1);\n    return +res.toString();\n}\n\nfunction encode({ precision = DEFAULT_PRECISION, thirdDim = ABSENT, thirdDimPrecision = 0, polyline }) {\n    // Encode a sequence of lat,lng or lat,lng(,{third_dim}). Note that values should be of type BigNumber\n    //   `precision`: how many decimal digits of precision to store the latitude and longitude.\n    //   `third_dim`: type of the third dimension if present in the input.\n    //   `third_dim_precision`: how many decimal digits of precision to store the third dimension.\n\n    const multiplierDegree = 10 ** precision;\n    const multiplierZ = 10 ** thirdDimPrecision;\n    const encodedHeaderList = encodeHeader(precision, thirdDim, thirdDimPrecision);\n    const encodedCoords = [];\n\n    let lastLat = Num(0);\n    let lastLng = Num(0);\n    let lastZ = Num(0);\n    polyline.forEach((location) => {\n       const lat = Num(Math.round(location[0] * multiplierDegree));\n       encodedCoords.push(encodeScaledValue(lat - lastLat));\n       lastLat = lat;\n\n       const lng = Num(Math.round(location[1] * multiplierDegree));\n       encodedCoords.push(encodeScaledValue(lng - lastLng));\n       lastLng = lng;\n\n       if (thirdDim) {\n           const z = Num(Math.round(location[2] * multiplierZ));\n           encodedCoords.push(encodeScaledValue(z - lastZ));\n           lastZ = z;\n       }\n    });\n\n    return [...encodedHeaderList, ...encodedCoords].join('');\n}\n\nfunction encodeHeader(precision, thirdDim, thirdDimPrecision) {\n    // Encode the `precision`, `third_dim` and `third_dim_precision` into one encoded char\n    if (precision < 0 || precision > 15) {\n        throw new Error('precision out of range. Should be between 0 and 15');\n    }\n    if (thirdDimPrecision < 0 || thirdDimPrecision > 15) {\n        throw new Error('thirdDimPrecision out of range. Should be between 0 and 15');\n    }\n    if (thirdDim < 0 || thirdDim > 7 || thirdDim === 4 || thirdDim === 5) {\n        throw new Error('thirdDim should be between 0, 1, 2, 3, 6 or 7');\n    }\n\n    const res = (thirdDimPrecision << 7) | (thirdDim << 4) | precision;\n    return encodeUnsignedNumber(FORMAT_VERSION) + encodeUnsignedNumber(res);\n}\n\nfunction encodeUnsignedNumber(val) {\n    // Uses variable integer encoding to encode an unsigned integer. Returns the encoded string.\n    let res = '';\n    let numVal = Num(val);\n    while (numVal > 0x1F) {\n        const pos = (numVal & Num(0x1F)) | Num(0x20);\n        res += ENCODING_TABLE[pos];\n        numVal >>= Num(5);\n    }\n    return res + ENCODING_TABLE[numVal];\n}\n\nfunction encodeScaledValue(value) {\n    // Transform a integer `value` into a variable length sequence of characters.\n    //   `appender` is a callable where the produced chars will land to\n    let numVal = Num(value);\n    const negative = numVal < 0;\n    numVal <<= Num(1);\n    if (negative) {\n        numVal = ~numVal;\n    }\n\n    return encodeUnsignedNumber(numVal);\n}\n\nmodule.exports = {\n    encode,\n    decode,\n\n    ABSENT,\n    LEVEL,\n    ALTITUDE,\n    ELEVATION,\n};\n"],
  "mappings": "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",
  "names": []
}
